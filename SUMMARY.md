# PostgreSQLのタイムゾーン動作まとめ

## テスト環境

3つの異なるタイムゾーン設定のPostgreSQLインスタンスでテストを実施しました：
- `postgres-utc`: コンテナタイムゾーンUTC (±00:00)
- `postgres-jst`: コンテナタイムゾーンAsia/Tokyo (+09:00)
- `postgres-est`: コンテナタイムゾーンAmerica/New_York (-05:00)

各コンテナでは4種類のセッションタイムゾーン設定（デフォルト、UTC、Asia/Tokyo、America/New_York）をテストしました。

## テスト結果の重要な発見

### 1. timestamp型とtimestamptz型の基本的な違い

- **timestamp型**:
  - タイムゾーン情報を無視して入力された日時をそのまま保存
  - セッションタイムゾーンに関係なく常に同じ値が出力される
  - 例：「2023-01-01 12:00:00 UTC」を入力すると「2023-01-01 12:00:00」として保存（UTCは無視）

- **timestamptz型**:
  - 入力された日時をUTCに変換して内部保存
  - 出力時はセッションタイムゾーンに応じた表示に変換される
  - 例：「2023-01-01 12:00:00 UTC」を入力すると、JSTセッションでは「2023-01-01 21:00:00+09:00」と表示

### 2. タイムゾーン指定がない入力の扱い

- **timestamp型**: 単に日時のみを保存（「2023-01-01 12:00:00」）
- **timestamptz型**: セッションタイムゾーンの日時として解釈
  - JSTセッションでは「2023-01-01 12:00:00+09:00」（UTC: 03:00:00）として解釈
  - ESTセッションでは「2023-01-01 12:00:00-05:00」（UTC: 17:00:00）として解釈

### 3. セッションタイムゾーンの影響

- **timestamp型**: 影響なし
- **timestamptz型**: 同じデータでもセッションタイムゾーンによって表示が変わる
  - 例：UTCの「2023-01-01 12:00:00」は、JSTでは「2023-01-01 21:00:00+09:00」、ESTでは「2023-01-01 07:00:00-05:00」

### 4. コンテナタイムゾーンの影響

- コンテナタイムゾーンは主にデフォルトのセッションタイムゾーンに影響
- `now()`や`CURRENT_TIMESTAMP`などの日時関数の結果に影響
- Asia/Tokyoコンテナの`now()`は「2025-03-27 13:07:28.044758+09」
- America/New_Yorkコンテナの`now()`は「2025-03-27 00:07:28.136054-04」

### 5. タイムゾーン変換と`AT TIME ZONE`演算子

- timestamptz型のデータを別のタイムゾーンの表現に変換可能
- `AT TIME ZONE 'UTC'`で統一的なUTC表現に変換できる
- 例：JSTの「2023-01-01 12:00:00+09:00」→ UTC変換後「2023-01-01 03:00:00」

## 実用上の推奨事項

1. **タイムゾーンを考慮すべき場合は`timestamptz`型を使用**
   - 異なるタイムゾーンのユーザーがアクセスするシステム
   - グローバルなデータ連携が必要な場合

2. **ローカル時間のみが重要な場合は`timestamp`型も検討**
   - 営業時間や特定地域だけでの使用
   - タイムゾーン変換が不要な場合

3. **セッションタイムゾーンの適切な設定**
   - アプリケーション起動時に明示的に設定する
   - ユーザーのロケールに合わせて動的に変更する

4. **タイムスタンプ値の入力時は明示的なタイムゾーン指定を推奨**
   - 「2023-01-01 12:00:00」より「2023-01-01 12:00:00+09:00」のように指定
   - システム間連携ではUTC表記（「2023-01-01 12:00:00Z」）を推奨 